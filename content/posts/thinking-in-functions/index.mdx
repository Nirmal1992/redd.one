---
date: '2019-02-20'
category: Education
title: Thinking in functions
description: Function is a synonym for action. It's good when your actions have purpose, and their intent is clear. But how to write such functions?
image: thumbnail2.jpg
---

## Summary

- [x] Input and Ouput
- [ ] Pure and Impure
- [ ] High-order functions
- [ ] Compose, don't complicate
- [ ] Resources to read more

---

## Input and Output

Functions may accept arguments (input) and may return a value (output). This sounds obvious, but it's a primary instrument of function design that is often overlooked. In practice this ability to accept and return things is a powerful architectural detail that we can use to create better functions.

Try writing your functions by first answering these two questions:

1. **What is this function's input?**
1. **What is this function's output?**

Doing so helps you to put technical details aside and perceive a function as an input/output operation, which it is. Those answers often hint implementational details, but most importantly they define clear constrains over a function's responsibility even before any code is written.

> You may operate with abstract types when answering those questions. For example, you can describe a function that accepts a list of foxes and returns a bear. These abstractions help you even more to focus on the function's characteristics.

```ts
function myFunc(list: number[]): number {}
```

Defining a function's input and output signatures is an absolute must to retain a clear understanding of what the function should and should not do.

Apart from that, a function's output may serve as the other function's _input_. This characteristics makes functions composable. And because we start writing our functions from those two questions, we can design entire pipelines of operations that achieve the required goal.

```ts
const getUser = (id: string) => User
const getPosts = (user: User) => Post[]
const getLikes = (posts: Post[]) => number

// getUser -> getPosts -> getLikes
```

There is one more hidden gem about this approach. Imagine you have asked yourself these questions, and your answer was: "_my function accepts the list of strings and returns a number_". Congratulations, you have just written a unit test for your function!

```js
expect(myFunc(['a', 'b', 'c'])).toEqual(2)
```

To recap, understanding a function's input and output types effectively defines a specification for that function: a function's call signature, and a unit test. Implementing things according to specification is a pleasant and safe way of programming that keeps you from leading astray.

---

## Pure and Impure

...

---

## High-order functions

_High-order function_ is a function that accepts another function as an argument, or returns a function. Think of it as a context provider that executes a given action.

### Accepting a function

Let's say we have an application that performs a lot of user operations based on their authentication status. What we may end up doing is checking the status in each of those individual operations:

```js
function getLatestPosts = (user) => {
  return user.isAuthenticated ? fetchPosts(user) : null
}

function addComment = (user, comment) => {
  return user.isAuthenticated ? postComment(user, comment) : null
}
```

You can see how often we need to repeat `user.isAuthenticated` each time we want to check if a user is authenticated. The worst part is that in reality it may be much more complicated to determine an authentication status than simply relying on `isAuthenticated` property.

We can encapsulate the logic that determines authentication and make the performed action parametric instead.

```js
function withAuthentication(user, action) {
  return user.isAuthenticated ? action(user) : null
}

function getLatestPosts(user) {...}

const latestPosts = withAuthentication(user, getLatestPosts)
```

The `withAuthentication` function above is a high-order function because it accepts another function (`action`) as the second argument.

* Add an explanation why HOF is more efficient than doing this:

```js
const withAuthentication = (user) => {
  return user.isAuthenticated
}

const getLatestPosts = (user) => {
  return withAuthentication(user) ? fetchPosts(user) : null
}
```

### Return a function

> Example when returning a function is useful.

- What is it?
- Why this are useful (with examples of already existing and custom hof)
- Declarative, deterministic
- (?) Warnings when using them

---

## Compose, don't complicate

Complexity is undesired, but unavoidable. Our task, as developers, is to prevent business complexity becoming programmatic complexity. For example, reusing existing code rather than introducing new things is a common way to leverage this issue.

Speaking of functions, there may be functions that perform a lot of actions.

```js
Examples of a complicated function
```

Instead of writing a single complicated function, try to create two smaller, more strict functions, and let the third one be the combination of the previous two.

```js
Example of the same complicated function redone in composition
```

Strict small functions are easier to test and interchange with other functions, if needed, making your functions chain more maintainable.

> If you want to bring your composition skills further, I highly encourage you to read through Functional programming basics. Functional composition is one of the pillars of that paradigm, and it can teach you a lot regardless whether you want to adopt functional programming in your project.
