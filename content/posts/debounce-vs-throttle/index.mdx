---
date: 2019-12-20
category: Education
title: 'Debounce vs Throttle: Definitive Visual Guide'
description: A complete guide to learn the difference between debounce and throttle using visual examples. Never confuse the two again.
image: thumbnail.jpg
---

import Quote from '../../../src/components/mdx/Quote.js'

## Introduction

When it comes to debounce and throttle developers often confuse the two. That is for a reason: those functions often share the same call signature, making us doubt which one to use when, or what is the difference in the first place. If you are a visual learner, as myself, I hope this interactive guide will be useful for you to differentiate between `throttle` and `debounce` the next time you're about to use them.

## First things first

Throttling and debouncing are two ways to optimize event handling. Before we begin, I'd like to take a moment to quickly revise the basics of events. In this article I'm going to use JavaScript in all examples, yet the conepts they illustrate are not bound to any specific language.

Event is an action that occurs in the system. For example, when you resize a browser window you cause the "resize" event, and when you click on a button the "click" event fires. We are interested in events to attach our own logic to them. That logic is represented as a function that is called a handler function (because it handles an event). Such handler function examples may include updating a UI element on resize, or displaying a modal window after a button is clicked.

In JavaScript you can react to events using event listeners. _Event listener_ is a function that listens to the given event on an element and executes a handler function whenever that event occurs. To add an event listener to an element (target) you should use the [`addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) function:

```js
TARGET.addEventListener(EVENT_NAME, HANDLER, OPTIONS)
```

## Let's throw a ball!

Let's build a ball throwing machine. Our machine would have a button that, when pressed, throws a ball. To describe this cause-and-effect relation between the button click and a ball throw we can use `addEventListener` on our button element:

```js
const button = document.getElementById('button')

button.addEventListener('click', function() {
  throwBall()
})
```

This reads as: _whenever the `button` is clicked, execute `throwBall()` function_. The details of `throwBall` function are not important, as it represents _any logic_ bound to an event.

Hinges are tightened, the screws are steady, let's see our ingenious invention in action!

import DefaultEvents from './components/DefaultEvents.jsx'

<DefaultEvents />

Whenever we press the button we produce the "click" event, to which event listener reacts with the `throwBall()` function. In other words, 1 button click results into 1 handler function call and 1 ball being thrown.

<Quote>
  By default, event handler function executes with 1-1 ratio to the event call.
</Quote>

There are cases when such direct proportion may become undesired. For instance, what if throwing a ball was an expensive operation, or we couldn't afford to throw more than 1 ball in half a second? In those cases we would have to limit the amount of times our handler function is being called.

**Throttling** and **debouncing** are two most common ways to control a handler function response rate to an event. Let's analyze each of them more closely by tweaking our ball vendor machine.

---

## Throttle

A throttled function is called once per _N_ amount of time. Any additional function calls within the specified time interval are ignored.

### Implementing `throttle`

```js
function throttle(func, duration) {
  let shouldWait = false

  return function(...args) {
    if (!shouldWait) {
      func(...args)
      shouldWait = true

      setTimeout(function() {
        shouldWait = false
      }, duration)
    }
  }
}
```

> Depending on the use case such simplified implementation may not be enough. I recommend looking into [`lodash.throttle`](https://www.npmjs.com/package/lodash.throttle) and [`_.throttle`](https://underscorejs.org/#throttle) packages then.

The `throttle` function accepts two arguments: `func`, which is a function to throttle, and `duration`, which is the duration of the throttling interval. It returns a _throttled function_. There are implementations that also accept the `leading` and `trailing` parameters that control the first (leading) and the last (trailing) function calls, but I'm going to skip those to keep the example simple.

To throttle our machine's button click we need to pass the event handler function as the first argument to `throttle`, and specify a throttling interval as the second argument:

```js
button.addEventListener(
  'click',
  throttle(function() {
    throwBall()
  }, 500)
)
```

Here's how our patched ball machine would work with the throttling applied:

import ThrottledEvents from './components/ThrottledEvents.jsx'

<ThrottledEvents />

No matter how often we click the button a ball won't be thrown more than once per throttled interval (`500ms` in our case). That's a great way of keeping our ball machine from overheating during the busy hours!

### When to use `throttle`?

Use `throttle` to _consistently_ react to a frequent event.

This technique ensures consistent function execution within a given time interval. Since throttle is bound to a timeframe, a dispatched handler should be ready to accept an intermediate state of event.

**Common use cases for a throttled function:**

- Any UI update based on window size (`window.addEventListener('resize')`)
- Performance-heavy operations on the client or server

---

## Debounce

A debounced function is called after _N_ amount of time passes since its last call. It reacts to a seemingly resolved state and implies a delay between the event and the handler function invocation.

### Implementing `debounce`

```js
function debounce(func, duration) {
  let timeout

  return (...args) => {
    const effect = () => {
      timeout = null
      return func(...args)
    }

    clearTimeout(timeout)
    timeout = setTimeout(effect, duration)
  }
}
```

> Depending on the use case such simplified implementation may not be enough. I recommend looking into [`lodash.debounce`](https://www.npmjs.com/package/lodash.debounce) and [`_.debounce` ](https://underscorejs.org/#debounce) packages then.

The `debounce` function accepts two arguments: `func`, which is a function to debounce, and `duration`, which is the amount of time (in ms) to pass from the last function call. It returns a _debounced function_.

To apply debouncing to our example we would have to wrap the button click handler in the `debounce`:

```js
button.addEventListener(
  'click',
  debounce(function() {
    throwBall()
  }, 500)
)
```

While the call signature of `debounce` is often similar to the one in `throttle`, it produces a much different effect when applied. Let's see how our machine will behave if its button clicks are debounced:

import DebouncedEvents from './components/DebouncedEvents.jsx'

<DebouncedEvents />

If we keep pressing the button fast enough no balls will be thrown at all, unless a debounce duration (`500ms`) passes since the last click. It is if our machine treats any amount of button clicks within a time period as _a single event_ and handles to it correspondingly.

### When to use `debounce`?

Use debounce to _eventually_ react to a frequent event.

Debounce is useful when you don't need an intermediate state and wish to respond to the end state of the event. That being said, you need to take into account an inevitable delay between the event and the response to it when using `debounce`.

**Common use cases for a debounced function:**

- Asynchronous search suggestions
- Updates batching on the server

---

## Afterword

I hope this article helps you and your teammates to understand the difference between `throttle` and `debounce` for good.

> Special thanks to [Alexander Fernandes](https://codepen.io/AlexRA96) for "Ball Bouncing Physics" project used for ball vendor machine example.
