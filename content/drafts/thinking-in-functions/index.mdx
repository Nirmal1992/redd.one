---
draft: true
date: '2019-08-01'
category: Education
title: Thinking in functions
description: Function is a synonym for action. It's good when your actions have purpose, and their intent is clear. But how to write such functions?
keywords:
  - function
  - thinking
  - input output
  - compose
  - functional programming
image: thumbnail2.jpg
socialShareText: Now when you weild such knowledge, it's your rightful duty to share it with your friends and colleagues.
---

import Quote from '../../../src/components/mdx/Quote.js'

## Summary

- [x] Input and Ouput
- [ ] Pure and Impure
- [ ] High-order functions
- [ ] Compose, don't complicate
- [ ] Resources to read more

---

## Input and Output

Functions may accept arguments (input) and may return a value (output). This sounds obvious, but it's a primary instrument of function design that is often overlooked. In practice this ability to accept and return things is a powerful architectural detail that we can use to create better functions.

Try writing your functions by first answering these two questions:

1. What is this function's **input**?
1. What is this function's **output**?

Doing so helps you to put technical details aside and perceive a function as an input/output operation, which it is. Those answers often hint implementational details, but most importantly they define clear constrains over a function's responsibility even before any code is written.

> You may operate with abstract types when answering those questions. For example, you can describe a function that accepts a list of apples and returns a fox. Such abstractions help you focus on a function's intent event more, but it's crucial to keep primitives like "string", "number", "list", etc.

```ts
function myFunc(list: number[]): number {}
```

Defining a function's input and output signatures is an absolute must to retain a clear understanding of what that function should and should not do.

Apart from that, a function's output may serve as the other function's _input_. This characteristics makes functions composable. And because we start writing our functions from those two questions, we can design entire pipelines of operations and have guarantee it would work as expected.

```ts
const getUser = (id: string) => User
const getPosts = (user: User) => Post[]
const getLikes = (posts: Post[]) => number

// getUser -> getPosts -> getLikes
```

There is one more hidden gem about this approach. Imagine you have asked yourself these questions, and your answer was: _"my function accepts a list of strings and returns a number"_. Congratulations, you have just written a unit test for your function!

```js
expect(myFunc(['a', 'b', 'c'])).toEqual(2)
```

Understanding a function's input and output types effectively defines a specification for that function: a function's call signature, and a unit test. Implementing things according to specification is a pleasant and safe way of programming that keeps you from leading astray.

---

## Pure and Impure

Functions often operate on data. That data can be internal (arguments, scoped variables), or external (databases, loggers, DOM). A function that operates only on internal data is called _pure_. A function that operates on external data or performs side-effects is called _impure_.

Since you are now designing your functions with their input/output in mind, you are gaining control over their purity as well. Despite of what you may have heard, you shouldn't praise pure functions and despise impure ones. You should treat them as different beasts, knowing their behavior and what to expect of them.

This is a highly practical topic, so I will approach it with examples.

- Is this function contextful? What makes it so?
- Would this function run when stripped out from its context?

### Pure functions

A pure function never mutates data it doesn't own, never performs side-effects, and has everything it needs handed to it via arguments, or local variables. It also has a particularly interesting mathematical characteristic:

<Quote>Given the same input a pure function returns the same output.</Quote>

[TODO] Relpace dummy example with a real-world example of some calculations. Highlight how relying on external data is a bad idea, and how making a function pure makes it trustworthy.

I would recommend to make any calculative function a pure function.

```js
function multiply(a, b) {
  return a * b
}

multiply(2, 5) // 10
multiply(2, 5) // 10
```

> Predictable output of a pure function makes it testable and trustworthy.

### Impure functions

If a function can't guarantee the same output given the same input it's called an _impure function_. Such functions often rely on a data they don't own, like reading external variables, performing a backend request, or writing to the file system.

For example, take a look at this function:

```js
let n = 1

function addTwo() {
  // Variable "n" is declared in the upper scope,
  // making "addTwo" function rely on external context.
  return n + 2
}

addTwo() // 3
```

Although the `addTwo` function _doesn't own_ the `n` varialbe (it hasn't been declared in its scope), it can read it and become dependent on it. It may look fine at first, but keep in mind that a context surrounding the function may change.

```js
function contextOne() {
  // This context has the "n" variable equal to another number.
  let n = 5

  // Our function will look up the "n" variable in the upper scope
  // and perform an addition.
  addTwo() // 5 + 2 = 7
}

function contextTwo() {
  // This context doesn't have the "n" variable declared,
  // which means the "addTwo" function will attempt to add:
  // undefined + 2
  addTwo() // NaN
}
```

> As you may see we can't predict what the `addTwo` function will return because **it doesn't know that itself**, and its result depends on extrenal factors.

You may be wondering: _"Why would I ever write such function?"_ The truth is, we work with the data we don't own all the time, and there is absolutely nothing wrong with relying on that data. Instead it's necessary to understand what implications this brings to our functions.

#### Side-effects

There's one more thing that makes a function impureâ€”_side effects_.

Side effect is an action of changing a state that hasn't been declared within a function. It's called "side" effect, because the "main" intention of a function is to return a value.

Using the same impure function example we can change it to perform a side effect:

```js
let n = 1

function addTwo() {
  // Instead of reading the external "n" variable
  // we are *changing* its value, mutating the state (n)
  // that "addTwo" function doesn't own.
  n = 3
}

addTwo() // undefined
console.log(n) // 3
```

However, there is a more common example of a side effect you've seen and even written yourself:

```js
console.log()
```

> That's right, calling `console.log` is a side effect, because it changes a browser's console state, which your application doesn't own.

Such common side effects also include:

- Manipulating the DOM (`appendChild`, `removeChild`, etc.)
- Performing an API request
- **SOMETHING ELSE?**

Side effects are far more dangerous than just reading an external data, because not only they rely on it, but they also _change it_. If you combine a dynamic nature of context where a side effect-ish function can be called and its intention to mutate this context, you may end up with things mutating all around. This is something you want to avoid by following the golden rule:

<Quote>Do not mutate the data you don't own.</Quote>

> Explain that side effects are still fine, and local mutations are fine, but don't mutate all the things around.

### Purity as a tool

In practice try to divide your functions so that impure ones deliver the data you need, and pure ones transform and operate on that data as if it's already been there.

```js
function getFriends(userId) {
  return fetch('https://backend.dev/users').then((res) => res.json())
}

function onlyNearbyFriends(friend) {
  return friend.location > 0
}

function mapExample(friend) {
  return friend.firstName
}

function renderFriendsList(userId) {
  return getFriends(userId).then((friendsList) => {
    const friendsNearby = friendsList.filter(onlyNearbyFriends).map(mapExample)
    return render(friendsNearby)
  })
}
```

#### Pure:

- Any kind of transformation of a known data (mapping, filtering, reducing, etc.)

#### Impure:

- Asynchronous operations (API requests, manipulating the DOM)

---

## High-order functions

_High-order function_ is a function that accepts another function as an argument, or returns a function. Think of it as a context provider that executes a given action. High-order functions is one of the greatest concepts to leverage code complexity without sacrificing ...

### Accepting a function

Let's say we have an application that performs a lot of user operations based on their authentication status. What we may end up doing is checking the status in each of those individual operations:

```js
function getLatestPosts(user) {
  return user.isAuthenticated ? fetchPosts(user) : null
}

function addComment(user, comment) {
  return user.isAuthenticated ? postComment(user, comment) : null
}
```

You can see how often we need to repeat `user.isAuthenticated` each time to check if a user is authenticated. The worst part is that in reality it's often much more complicated to determine an authentication status than simply relying on a single property. Repeating that logic each time is not what you want.

Our next step to get rid of that repetition may be to separate authentication check logic into its own function, and call it on the usage level:

```js
// Determine authentication of the given user
function isAuthenticated(user) {
  return user.isAuthenticated && moreComplicatedFactors(user)
}

function getLatestPosts(user) {
  // Reuse the function
  return isAuthenticated(user) ? fetchPosts(user) : null
}

function addComment(user) {
  return isAuthenticated(user) ? postComment(user, comment) : null
}
```

> Would this be enough? It does look good, what is the argument to use HOF instead?

[...] We can encapsulate the logic that determines authentication and make the performed action parametric instead.

```js
function withAuthentication(user, action) {
  return user.isAuthenticated ? action(user) : null
}

function getLatestPosts(user) {...}

const latestPosts = withAuthentication(user, getLatestPosts)
```

The `withAuthentication` function above is a high-order function because it accepts another function called `action` as the second argument.

- Add an explanation why HOF is more efficient than doing this:

```js
const withAuthentication = (user) => {
  return user.isAuthenticated
}

const getLatestPosts = (user) => {
  return withAuthentication(user) ? fetchPosts(user) : null
}
```

### Return a function

> Example when returning a function is useful.

- What is it?
- Why this are useful (with examples of already existing and custom hof)
- Declarative, deterministic
- (?) Warnings when using them

---

## Compose, don't complicate

Complexity is undesired, but unavoidable. Our task, as developers, is to prevent business complexity becoming a programmatic complexity. For example, reusing existing code rather than introducing new things is a common way to leverage this issue.

Speaking of functions, there is an approach to cope with their complexity, and it's called _functional composition_. Imagine we have a function that does a lot.

```js
// Examples of a complicated function
```

Instead of writing a single complicated function, try to create two smaller, more isolated functions, and let the third one be the combination of the previous two. Utilize the knowledge of the input/output function design pattern to determine how to compose functions.

```js
// Example of the same complicated function redone in composition

const simpleA = () => {}
const simpleB = () => {}

const complexFunc = (arg) => simpleB(simpleA(arg))
```

> Remember that you can compose two functions only if the return type of the first function is the input type for the second. This limitation makes you put more thought into making functions properly composable (reusable), and helps writting functions with strict purpose.

[TODO] Benefit of a composition: illustrate how easy it's to add a new operation on top of the composition without refactoring anything. Maybe now it's a composition of three functions.

Applying this principle for a large chain of functions may lead into a nesting problem, where our composition would become an ugly, terrifying monstrosity:

```js
const func = (arg) => e(d(c(b(a(arg)))))
```

To eradicate the nesting of function calls, you can use a `compose` function:

```js
function compose(...funcs) {
  return funcs.reduce((f, g) => (...args) => f(g(...args)))
}

const complexFunc = compose(
  simpleB,
  simpleA
)(arg)
```

> Note that the invocation order of functions inside a composition is right-to-left (or bottom-to-top). If you find this confusing, take a look at compose's alternative called [`pipe`](https://ramdajs.com/docs/#pipe).

### Benefits of composition

As stated earlier, composition is an architecture design challenge, and by forcing you to put more thoughts into how your functions operate, you effectively end up with better written functions. This is the extension of the input/output pattern which helps you to write more effective functions, but in case of functional composition it applies to the entire _sequence of operations_.

Perhaps, the following illustration may help you to understand the difference between the "monolithic" and compositional function design:

> INSERT AN IMAGE HERE. Consists of two halfs: left part demostrates a monolith of a function, the right half illustrate lego-ish functional composition.

Small deterministic functions are easier to test and interchange if needed, making your functions chain more maintainable in the long run.

[...]

---

If you want to bring your composition skills further, I highly recommend you to read through the Functional programming fundamentals. Functional composition is one of the pillars of that paradigm, and it can teach you a lot, regardless whether you want to adopt functional programming in your project.
